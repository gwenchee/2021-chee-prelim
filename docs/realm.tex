\chapter{REALM: Reactor Evolutionary Algorithm Optimizer}
% Main Gist 
% - Genetic Algorithms / DEAP have been applied to a multitude of problems, 
%   but barely to nuclear. DEAP was created to be easily coupled with other
%   codes and to flexibly build your own reactor. 
% Structure 
% - Realm framework
% - Coupling to OpenMC and Moltres

In this chapter, I introduce the \gls{REALM} Python framework developed for the
proposed work.
\gls{REALM} applies \gls{EA} optimization to nuclear reactor design, and 
strives to be effective, flexible, open-source, parallel, reproducible, 
and usable. 
I briefly summarize how \gls{REALM} achieves these goals:  
\begin{itemize}
    \item Effective: \gls{REALM} is well documented, well tested, and 
    version-controlled on Github \cite{chee_arfcrealm_2021}.
    \item Flexible: The proposed work's goal is to utilize \gls{REALM} to 
    explore arbitrary reactor geometries and inhomogeneous fuel distributions. 
    However, I acknowledge that future users might want to utilize \gls{REALM} 
    with other arbitrary parameters that I overlooked. Thus, I designed the \gls{REALM}
    framework with this in mind. The user is able to vary any imaginable parameter 
    as \gls{REALM} uses a templating method to edit the coupled software's input 
    file.
    \item Open-source: I utilized a well-documented open-source \gls{EA} Python 
    package to drive the genetic algorithm optimization. I utilized established 
    open-source nuclear transport, OpenMC \cite{romano_openmc_2013}, and 
    thermal-hydraulics, Moltres \cite{lindsay_introduction_2018}, software to 
    compute the objective function and constraints. I also provide a simple 
    tutorial for future developers to follow for coupling other nuclear software 
    to the \gls{REALM} package.  
    \item Parallel: \gls{REALM} runs parallel on \gls{HPC} machines using the 
    \texttt{multiprocessing\_on\_dill} Python package 
    \cite{smallshire_multiprocessing_on_dill_nodate}.
    \item Reproducible: Data from every REALM run saves into a unique pickled file
    and all results from this work is available on Github. 
    \item Usable: I did not reinvent the wheel--instead combined available 
    evolutionary algorithm, nuclear transport, and thermal-hydraulics software, 
    to create a new optimization tool for easy leveraging of evolutionary algorithms 
    to construct arbitrary reactor designs. 
\end{itemize}

Next, I will describe \gls{REALM}'s framework and the specifics about how 
I designed \gls{REALM} to achieve these goals. 

\section{\acrlong{REALM}'s Framework}
\gls{REALM} essentially couples an evolutionary algorithm driver with nuclear 
software such as, nuclear transport and thermal-hydraulics codes. 
Figure \ref{fig:genetic_alg} from Chapter \ref{chap:lit-review} outlined an 
evolutionary algorithm's iterative problem solving process. 
I modified Figure \ref{fig:genetic_alg} to produce Figure 
\ref{fig:genetic_alg_nuclear} which depicts how the nuclear transport and 
thermal-hydraulics software fit within the process. 
\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=1.7cm]
            \tikzstyle{every node}=[font=\small]
            \node (1) [lbblock] {\textbf{Create initial population}};
            \node (2) [loblock, below of=1] {\textbf{Evaluate initial population}};
            \node (3) [lbblock, below of=2, yshift = -1.3cm] {\textbf{Create new population:} \\ 
            \begin{enumerate} \item \textbf{Select} individuals for mating 
                              \item Create offspring by \textbf{crossover} 
                              \item \textbf{Mutate} selected individuals 
                              \item Keep selected individuals from previous generation
                             \end{enumerate}};
            \node (4) [loblock, below of=3, yshift=-1.3cm] {\textbf{Evaluate new population}};
            \node (5) [lbblock, below of=4] {\textbf{Is termination criteria satisfied?}};
            \node (6) [lbblock, below of=5] {\textbf{Best solution is returned!}};
            \draw [arrow] (1) -- (2);
            \draw [arrow] (2) -- (3);
            \draw [arrow] (3) -- (4);
            \draw [arrow] (4) -- (5);
            \draw [arrow] (5) -- node[anchor=east] {yes} (6);
            \draw [arrow] (5) -- ([shift={(0.5cm,0cm)}]5.east)-- node[anchor=west] {no} ([shift={(0.5cm,0cm)}]3.east)--(3);
            \matrix [draw,above right,yshift=10.7cm, xshift=0cm] at (current bounding box.south east) {
            \node [bbblock,label=right:\textbf{EA: Evolutionary algorithm}] {}; \\
            \node [boblock,label=right:\textbf{NS: Nuclear software}] {}; \\
            };
    \end{tikzpicture}
    \caption{Process of finding optimal solutions for a problem with a 
    genetic algorithm with evaluation conducted with nuclear software.}
    \label{fig:genetic_alg_nuclear}
\end{figure}
Therefore, \gls{REALM} will initially read and validate the \texttt{json} input 
file, initialize the \gls{DEAP} genetic algorithm hyperparameters and operators, 
and finally run the genetic algorithm following the flow chart in Figure 
\ref{fig:genetic_alg_nuclear} in which the nuclear software evaluates each 
individual's fitness. 
Next, I will describe evolutionary algorithm software that drives \gls{REALM} 
and details about the \gls{REALM} framework. 

\subsection{Evolutionary Algorithm Driver}
Evolutionary algorithm computation is a sophisticated field with diverse techniques 
and mechanisms, resulting in even well designed coded-up frameworks being complicated 
under the hood \cite{fortin_deap_2012}. 
Therefore, utilizing a previously used evolutionary algorithm framework brings 
up issues in extending implementation intricacies as the user has to edit the 
source code. 
This is concerning since using evolutionary algorithms to solve unique real-world 
problems requires customization of algorithms \cite{fortin_deap_2012}. 
Therefore, an evolutionary algorithm computation framework that gives the user the 
capability to build custom evolutionary algorithms is ideal for this project.

There are many evolutionary algorithm computation packages available: 
\gls{DEAP} \cite{fortin_deap_2012}, inspyred \cite{garrett_inspyred_2014}, 
Pyevolve \cite{perone_pyevolve_2009}, and OpenBEAGLE \cite{gagne_open_2002}.
\gls{DEAP} is the most newly created package and places a high value on code 
compactness and code clarity \cite{fortin_deap_2012}. 
\gls{DEAP} is the only framework that allows the user to rapidly prototype 
evolutionary algorithms and define custom algorithms without having to dig 
deep into the source code to modify lines,  making it the code of choice for 
the evolutionary algorithm driver component of the \gls{REALM} framework.  
\gls{DEAP} provides building blocks for each optimizer function and allows the 
user to customize and design a specialized algorithm to fit their project
\cite{fortin_deap_2012}.

\subsubsection{How \gls{DEAP} works}
\label{sec:deap-works}
\gls{DEAP} is composed of two simples structures: a \textit{creator} and a 
\textit{toolbox}.  
The \textit{creator} module is a meta-factory that allows the run-time creation 
of classes via inheritance and composition. 
This enables the creation of individuals and populations from any data structure: 
lists, sets, dictionaries, trees, etc \cite{fortin_deap_2012}. 
The \textit{toolbox} is a container for the tools/operators that the user 
manually populates with selected tools for the evolutionary algorithm.
The \textit{toolbox} is where the user would define the selection, crossover, 
and mutation operator types and hyperparameters. 
For example, the user would register a crossover operator under the `mate'
alias. 
Then, the evolutionary algorithms would be built with these aliased operators, 
and if the user wanted to change the crossover operator, they would update the 
`mate' alias in the toolbox and the algorithm would remain unchanged
\cite{fortin_deap_2012}. 

Figure \ref{fig:deap-code} illustrates DEAP's usage of the \textit{creator} and
\textit{toolbox} modules. 
\begin{figure}[]
    \begin{minted}[
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        fontsize=\footnotesize,
        linenos
        ]{python}
        
        from deap import creator, base, tools, algorithms
        creator.create("Objective", base.Fitness, weights=(-1.0,)) # minimum
        creator.create("Individual", list, fitness=creator.Objective)

        toolbox = base.Toolbox()
        toolbox.register("variable_1", random.uniform, 0.0, 10.0)
        toolbox.register("variable_2", random.uniform, -1.0, 0.0)
        def individual_creator():
            return creator.Individual([toolbox.variable_1(), toolbox.variable_2()])
        toolbox.register("individual", individual_creator())
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
        def evaluator_fn(individual):
            return tuple([sum(individual)])
        toolbox.register("evaluate", evaluator_fn)
        toolbox.register("select", tools.selBest, k=5)
        toolbox.register("mutate", tools.mutPolynomialBounded, eta=0.5, low=[0, -1], up=[-1, 0])
        toolbox.register("mate", tools.cxOnePoint)
    \end{minted}
    \caption{DEAP sample code demonstrating the usage of the \textit{creator} and
    \textit{toolbox} modules to initialize the genetic algorithm.}
    \label{fig:deap-code}
\end{figure}
On line 2, a single-objective fitness class \texttt{Objective} is created. 
The first argument defines the name of the derived class, the second argument 
specifies the inherited base class (\texttt{base.fitness}), and the third 
argument is the weights attribute initialized with a tuple that indicates
one-objective fitness ($-1.0$ indicates a minimum objective, and $+1.0$ 
indicates a maximum objective). 
On line 3, an \texttt{Individual} class is derived from the Python list and 
composed with our newly created \texttt{Objective} object. 
On lines 5-9, we initialize the \gls{DEAP} toolbox, register 
\texttt{variable\_1} and \texttt{variable\_2} with their upper and lower bounds, 
and defined the \texttt{individual\_creator} function to return an 
\texttt{Individual} initialized with \texttt{variable\_1} and \texttt{variable\_2}. 
Lines 10-11 and 14-17 have aliases for initializing individuals and population, 
specifying variation operators (\texttt{select}, \texttt{mutate}, \texttt{mate}), 
and evaluating individual fitness (\texttt{evaluate}) \cite{fortin_deap_2012}. 
Lines 12-13 defines the evaluation function that returns the fitness values. 
In \gls{REALM}, the evaluation function will run the nuclear software and 
return user-defined fitness values.  

\subsection{Nuclear Software}
Many nuclear software have restricted public access. 
In the proposed work, I enabled \gls{REALM} to work with open-source nuclear 
transport and thermal-hydraulics software, OpenMC \cite{romano_openmc_2013} 
and Moltres \cite{lindsay_introduction_2018}.  
OpenMC is an open-source Monte Carlo neutron transport code, that is capable of 
performing k-eigenvalue calculations on models built using either constructive 
solid geometry or CAD representation. 
OpenMC can run in parallel using a hybrid MPI and OpenMP programming model. 
Moltres is an open-source tool designed for simulation of \glspl{MSR} using 
deterministic neutronics and thermal-hydraulics, implemented as an application 
atop the \gls{MOOSE} finite-element framework.  
Moltres solves arbitrary-group neutron diffusion, temperature, and precursor 
governing equations on a single mesh and can be deployed on an arbitrary number 
of processing units \cite{lindsay_introduction_2018}.

OpenMC and Moltres are both open-source, well-documented, well-supported, and 
Github version controlled codes that run in parallel on \gls{HPC} machines, 
thus, achieving the \gls{REALM} goals listed at the start of this chapter, 
making them suitable to be used as \gls{REALM}'s nuclear software.
However, \gls{REALM} users can easily use restricted nuclear software with 
\gls{REALM} by using \gls{REALM} with the restricted software on their local 
machine. 

\subsection{REALM Input File}
REALM's input file is in \texttt{json} format. 
There are four sections that the user must define: \\ \texttt{control\_variables}, 
\texttt{evaluators}, \texttt{constraints}, and \texttt{algorithm}. 
Figure \ref{fig:realm-input} shows an example REALM input file. 
\begin{figure}[]
    \begin{minted}[
        frame=lines,
        framesep=2mm,
        baselinestretch=1.2,
        fontsize=\footnotesize,
        linenos
        ]{json}
        {
            "control_variables": {
                "variable_1": {"min": 0.0, "max": 10.0}, 
                "variable_2": {"min": -1.0, "max": 0.0}
            }, 
            "evaluators": {
                "openmc": {
                    "input_script": "openmc_inp.py",
                    "output_script": "openmc_output.py", 
                    "inputs": ["variable_1", "variable_2"],
                    "outputs": ["output_1", "output_2"]
                }
            }, 
            "constraints": {
                "output_1": {"operator": [">="], "constrained_val": [1.0]}
            }, 
            "algorithm": {
                "objective": "min", 
                "optimized_variable": "output_1", 
                "pop_size": 100, 
                "generations": 10, 
                "mutation_probability": 0.5,
                "mating_probability": 0.5,
                "selection_operator": {"operator": "selBest", "k": 1},
                "mutation_operator": {
                    "operator": "mutPolynomialBounded",
                    "indpb": 0.5,
                    "eta": 0.5
                },
                "mating_operator": {"operator": "cxOnePoint"}
            }
        }
    \end{minted}
    \caption{REALM sample input file.}
    \label{fig:realm-input}
\end{figure}
The control variables are parameters that the user wants the genetic algorithm 
to vary. 
For each control variable, the user must specify the minimum and maximum value 
(lower and upper bounds). 

\subsection{REALM Software Architecture}
In this section, I will describe \gls{REALM} v1.0's software architecture and 
how all the parts come together to meet the goal of optimizing reactor 
design. 
Table \ref{tab:realm-architecture} outlines the classes in the REALM software 
and describes each class' purpose.
\begin{table}[]
    \centering
    \onehalfspacing
    \caption{Classes that make up REALM's architecture and their description. }
	\label{tab:realm-architecture}
    \small
    \begin{tabular}{l|p{0.77\textwidth}}
    \hline
    \textbf{Class} & \textbf{Description} \\ \hline
    \textbf{\textit{InputValidation}} & The \textbf{\textit{InputValidation}} class contains methods 
    to read the \texttt{json} \gls{REALM} input file and conduct a validation to 
    ensure the user defined all key parameters, and if they did not, \gls{REALM} 
    raises an exception to tell the user which parameters are missing. \\
    \hline
    \textbf{\textit{Evaluation}} & \gls{DEAP}'s fitness evaluator (as mentioned in Section 
    \ref{sec:deap-works}) requires an evaluation function to evaluate each 
    individual's fitness values. 
    The \textbf{\textit{Evaluation}} class contains a method that returns an evaluation 
    function that runs the nuclear software and returns the fitness values defined 
    in the user input file. \\
    \hline 
    \textbf{\textit{OpenMCEvaluation}} & The \textbf{\textit{OpenMCEvaluation}} class contains
    built-in methods for evaluating OpenMC output files. Developers can update 
    this file with methods to evaluate frequently used OpenMC outputs. \\
    \hline 
    \textbf{\textit{ToolboxGenerator}} & The \textbf{\textit{ToolboxGenerator}} class initializes
    DEAP's \textit{toolbox} and \textit{creator} modules with genetic algorithm 
    hyperparameters defined in the user input file.\\
    \hline
    \textbf{\textit{Constraints}} & The \textbf{\textit{Constraints}} class contains methods to 
    initialize constraints defined in the user input file and to apply the
    constraints in the genetic algorithm by removing individuals that do 
    not meet the constraint.\\
    \hline 
    \textbf{\textit{BackEnd}} & The \textbf{\textit{BackEnd}} class contains methods to save 
    genetic algorithm population results into a pickled checkpoint file and to 
    restart a partially completed genetic algorithm from the checkpoint file. \\
    \hline
    \textbf{\textit{Algorithm}} & The \textbf{\textit{Algorithm}} class contains methods to 
    initialize and execute the genetic algorithm. It executes a general genetic 
    algorithm framework that uses the hyperparameters defined in the 
    \textbf{\textit{ToolboxGenerator}}, applies constraints defined in
    \textbf{\textit{Constraints}}, evaluates fitness values using the evaluation 
    function produced by \textbf{\textit{Evaluation}}, and saves all the results 
    with \textbf{\textit{BackEnd}}. \\
    \hline
    \textbf{\textit{Executor}} & The \textbf{\textit{Executor}} class drives the \gls{REALM} code
    execution with the following steps: \\
    & 1) User input file validation with \textbf{\textit{InputValidation}}. \\
    & 2) Evaluation function generation with \textbf{\textit{Evaluation}}. \\
    & 3) DEAP toolbox initialization with \textbf{\textit{ToolboxGenerator}}. \\ 
    & 4) Constraint initialization with \textbf{\textit{Constraints}}. \\ 
    & 5) Genetic algorithm execution with \textbf{\textit{Algorithm}}. \\
    \hline
    \end{tabular}
    \end{table}
Figure \ref{fig:realm_archi} depicts REALM's software architecture. 
\begin{figure}[]
    \centering
    \begin{tikzpicture}[node distance=0.5cm]
        \tikzstyle{every node}=[font=\footnotesize]
        \node (1) [b72block] {\textbf{\textit{InputValidation}}};
        \node (2) [b72block, below=of 1] {\textbf{\textit{Evaluation}}};
        \node (9) [b82block, left=of 2] {\textbf{\textit{OpenMCEvaluation}}};
        \node (3) [b72block, below=of 2] {\textbf{\textit{ToolboxGenerator}}};
        \node (4) [b72block, below=of 3] {\textbf{\textit{Constraints}}};
        \node (5) [b72block, below=of 4] {\textbf{\textit{BackEnd}}};
        \node (6) [b223block, right=of 2, yshift=0cm, xshift=0.6cm] 
        {\baselineskip=14.5pt \textbf{\textit{Executor}} \\ \raggedright 
        1) User input file validation with \textbf{\textit{InputValidation}} \\ 
        2) Evaluation function generation with \textbf{\textit{Evaluation}} \\ 
        3) DEAP toolbox initialization with \textbf{\textit{ToolboxGenerator}} \\ 
        4) Constraints initialization with \textbf{\textit{Constraints}} \\ 
        5) Genetic algorithm execution with \textbf{\textit{Algorithm}} \\};
        \draw [arrow] (1) -- ([shift={(0cm,0cm)}]1.east) -- ([shift={(-0.5cm,0.8cm)}]6.west)--([shift={(0cm,0.8cm)}]6.west);
        \draw [arrow] (2) -- ([shift={(0cm,0cm)}]2.east) -- ([shift={(-0.5cm,0.3cm)}]6.west)--([shift={(0cm,0.3cm)}]6.west);
        \draw [arrow] (9) -- ([shift={(0cm,0cm)}]9.east) -- ([shift={(0cm,0cm)}]2.west);
        \draw [arrow] (3) -- ([shift={(0cm,0cm)}]3.east) -- ([shift={(-0.5cm,-0.25cm)}]6.west)--([shift={(0cm,-0.25cm)}]6.west);
        \draw [arrow] (4) -- ([shift={(0cm,0cm)}]4.east) -- ([shift={(-0.5cm,-0.8cm)}]6.west)--([shift={(0cm,-0.8cm)}]6.west);
        \node (7) [b223block, right=of 4, yshift=-0.8cm, xshift=0.6cm] 
        {\baselineskip=14.5pt \textbf{\textit{Algorithm}} \\ \raggedright 
        1) Accepts initialized toolbox, constraints, and evaluator \\ \hspace{0.3cm} function \\
        2) Runs the genetic algorithm \\
        3) Saves results with \textbf{\textit{BackEnd}} \\};
        \draw [arrow] (7) -- ([shift={(0.cm,0.25cm)}]7.north) -| ([shift={(-0.5cm,-1.25cm)}]6.west) -- ([shift={(0cm,-1.25cm)}]6.west);
        \draw [arrow] (5) -- ([shift={(0cm,0cm)}]5.east) -- ([shift={(-0.5cm,-1cm)}]7.west)--([shift={(0cm,-1cm)}]7.west);
    \end{tikzpicture}
    \caption{Visualization of REALM architecture.}
    \label{fig:realm_archi}
\end{figure}


\section{Hyperparameter Search}
Hyperparameters are a model configuration argument specified by the developer to 
guide the learning process for a specific dataset. 